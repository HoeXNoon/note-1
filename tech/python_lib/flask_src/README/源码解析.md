# Flask源码解析

flask遵循wsgi的应用协议,
wsgi应用是一个函数接受两个参数environ,start_response  
例如:
```python
def application(environ,start_reponse):
    # environ是字典格式
    #处理客户端的请求信息,请求信息全部包含在environ中,
    # 处理完客户请求之后,构建相应信息
    status= '200 OK' #HTTP响应的起始行中 status 和 reason,
    headers=[('Content-Type','text/plain'),('Set-Cookie', 'ddd=aaa; Path=/')]
    start_response(status,headers)
    return '响应体'

```
> HTTP请求报文:  
> 起始行: method path version 例如 GET /api/v1/user HTTP/1.1  
> 请求头: key:value 有很多 例如:Host: www.baidu.com,  
> 数据或者叫请求体: 例如表单数据,json字符串等等  
> HTTP响应报文:  
> 起始行: version status reason 例如: HTTP/1.1 200 OK  
> 响应头: key:value 有很多,例如: Content-Type: application/json  
> 数据或者叫响应体: 例如:网页内容,json字符串,xml等等  

flask中通过Flask类实现了application,所以在Flask类中有`__call__`方法,  
具体是:
```python
# 位置 flask/app.py 
def __call__(self, environ, start_response):
    """The WSGI server calls the Flask application object as the
    WSGI application. This calls :meth:`wsgi_app` which can be
    wrapped to applying middleware."""
    return self.wsgi_app(environ, start_response)
```

# 请求与响应

flask中的请求与响应依赖于werkzeug.wrappers中Request和Response

## werkzeug.wrappers.Request
源代码
```python
class Request(BaseRequest, AcceptMixin, ETagRequestMixin,
              UserAgentMixin, AuthorizationMixin,
              CommonRequestDescriptorsMixin):
    pass
```
Request继承自BaseRequest, AcceptMixin, ETagRequestMixin,UserAgentMixin,AuthorizationMixin,CommonRequestDescriptorsMixin

属性和方法:

BaseRequest:
常用属性和方法
- args:返回字典类型数据,包含的是HTTP起始行中path中的参数
- data:HTTP请求体字符串
- form:如果客户端已表单提交数据,那么form是解析之后的表单数据字典
- files:如果客户端已表单提交数据并且包含了文件,那么files中包含文件字典
- cookies: 客户端携带的cookie数据字典
- headers: 请求头内容
- path: 路径,但是不包含?之后的信息
- full_path: 完整的路径

AcceptMixin: 
客户端请求头中的accpet字段内容
- accept_mimetypes: 客户端接收到请求数据类型
- accept_charsets: 客户端接受字符集
- accept_encodings: 客户端接受的编码
- accept_languages: 客户端接受的语言

ETagRequestMixin:
HTTP缓存相关控制,请查阅HTTP权威指南中解释
- cache_control
- if_match
- if_none_match
- if_modified_since
- if_unmodified_since
- if_range
- range

UserAgentMixin: 
HTTP中的用户代理信息
- user_agent:返回的是UserAgent对象:
    - string:请求头数据
    - platform:平台
    - browser:浏览器
    - version:版本
    - language:语言

AuthorizationMixin: 
HTTP中的HTTP_AUTHORIZATION请求头
- authorization:返回的是Authorization对象

CommonRequestDescriptorsMixin:
- content_length:请求体长度
- mimetype:请求体数据类型
- mimetype_params:请求体
- pragma:HTTP_PRAGMA
- content_encoding:对应请求头中 HTTP_CONTENT_ENCODING
- content_md5:对应请求头中 HTTP_CONTENT_MD5
- referrer:对应请求头中 HTTP_REFERER
- date:对应请求头中 HTTP_DATE
- max_forwards:对应请求头中 HTTP_MAX_FORWARDS

## werkzeug.wrappers.Response

Response是应用返回数据给客户端的终点,也就是application的`__call__`方法最后是为了返回数据给客户端,而application最后是返回了Reponse对象,Response对象通过实现`__call__(self,environ,start_response)`来实现wagi的应用协议
Response的call方法
```python
def __call__(self, environ, start_response):
    """Process this response as WSGI application.

    :param environ: the WSGI environment.
    :param start_response: the response callable provided by the WSGI
                            server.
    :return: an application iterator
    """
    app_iter, status, headers = self.get_wsgi_response(environ)
    start_response(status, headers)
    return app_iter
```

源代码
```python
class Response(BaseResponse, ETagResponseMixin, ResponseStreamMixin,
               CommonResponseDescriptorsMixin,
               WWWAuthenticateMixin):
```
BaseResponse:
- set_cookie:设置cookie

## 请求

Request继承自werkzeug.wrappers.Request和JSONMixin

```python
class Request(RequestBase, JSONMixin):
```
JSONMixin:
- is_json:判断请求是否发送的是json数据类型
- json: 如果请求的数据是json数据类型,那么这里获得的时候json数据字典

## 响应

Response继承自werkzeug.wrappers.Response和JSONMixin

```python
class Response(ResponseBase, JSONMixin)
```

# 路由

# session

flask中默认的session工具是`session_interface=SecureCookieSessionInterface`

flask通过调用
- open_session: 来打开获取session对象
- save_session: 来保存session对象

## 使用redis来保存session

```python
reds_conn = redis.Redis()


class RedisSession(object):
    def __init__(self, data={}, session_id=None):
        self.modified = False
        self.session_id = session_id
        self.data = data

    def __setitem__(self, key, value):
        self.modified = True
        self.data[key] = value

    def __getitem__(self, key):
        return self.data[key]

    def __repr__(self):
        return str(self.data)


class RedisSessionInterface(SessionInterface):
    def open_session(self, app, request):
        session_id = request.cookies.get(app.session_cookie_name, False)
        if not session_id:
            session_id = str(uuid.uuid1())
        data = reds_conn.get(session_id)
        if data:
            data = json.loads(data.decode())
        else:
            data = {}
        return RedisSession(data=data, session_id=str(uuid.uuid1()))

    def save_session(self, app, session, response):
        if session.modified:
            reds_conn.set(session.session_id, json.dumps(
                session.data), ex=app.permanent_session_lifetime)

        response.set_cookie(
            app.session_cookie_name,
            session.session_id,
            expires=datetime.utcnow() + app.permanent_session_lifetime,
            httponly=True
        )

app.session_interface = RedisSessionInterface()
```

 






