# Flask源码分析

flask遵循wsgi的应用协议,
wsgi应用是一个函数接受两个参数environ,start_response  
例如:
```python
def application(environ,start_reponse):
    # environ是字典格式
    #处理客户端的请求信息,请求信息全部包含在environ中,
    # 处理完客户请求之后,构建相应信息
    status= '200 OK' #HTTP响应的起始行中 status 和 reason,
    headers=[('Content-Type','text/plain'),('Set-Cookie', 'ddd=aaa; Path=/')]
    start_response(status,headers)
    return '响应体'

```
> HTTP请求报文:  
> 起始行: method path version 例如 GET /api/v1/user HTTP/1.1  
> 请求头: key:value 有很多 例如:Host: www.baidu.com,  
> 数据或者叫请求体: 例如表单数据,json字符串等等  
> HTTP响应报文:  
> 起始行: version status reason 例如: HTTP/1.1 200 OK  
> 响应头: key:value 有很多,例如: Content-Type: application/json  
> 数据或者叫响应体: 例如:网页内容,json字符串,xml等等  

flask中通过Flask类实现了application,所以在Flask类中有`__call__`方法,  
具体是:
```python
# 位置 flask/app.py 
def __call__(self, environ, start_response):
    """The WSGI server calls the Flask application object as the
    WSGI application. This calls :meth:`wsgi_app` which can be
    wrapped to applying middleware."""
    return self.wsgi_app(environ, start_response)
```

# 请求与响应

flask中的请求与响应依赖于werkzeug.wrappers中Request和Response

## werkzeug.wrappers.Request
源代码
```python
class Request(BaseRequest, AcceptMixin, ETagRequestMixin,
              UserAgentMixin, AuthorizationMixin,
              CommonRequestDescriptorsMixin):
    pass
```
Request继承自BaseRequest, AcceptMixin, ETagRequestMixin,UserAgentMixin,AuthorizationMixin,CommonRequestDescriptorsMixin

属性和方法:

BaseRequest:
常用属性和方法
- args:返回字典类型数据,包含的是HTTP起始行中path中的参数
- data:HTTP请求体字符串
- form:如果客户端已表单提交数据,那么form是解析之后的表单数据字典
- files:如果客户端已表单提交数据并且包含了文件,那么files中包含文件字典
- cookies: 客户端携带的cookie数据字典
- headers: 请求头内容
- path: 路径,但是不包含?之后的信息
- full_path: 完整的路径

AcceptMixin: 
客户端请求头中的accpet字段内容
- accept_mimetypes: 客户端接收到请求数据类型
- accept_charsets: 客户端接受字符集
- accept_encodings: 客户端接受的编码
- accept_languages: 客户端接受的语言

ETagRequestMixin:
HTTP缓存相关控制,请查阅HTTP权威指南中解释
- cache_control
- if_match
- if_none_match
- if_modified_since
- if_unmodified_since
- if_range
- range

UserAgentMixin: 
HTTP中的用户代理信息
- user_agent:返回的是UserAgent对象:
    - string:请求头数据
    - platform:平台
    - browser:浏览器
    - version:版本
    - language:语言

AuthorizationMixin: 
HTTP中的HTTP_AUTHORIZATION请求头
- authorization:返回的是Authorization对象

CommonRequestDescriptorsMixin:
- content_length:请求体长度
- mimetype:请求体数据类型
- mimetype_params:请求体
- pragma:HTTP_PRAGMA
- content_encoding:对应请求头中 HTTP_CONTENT_ENCODING
- content_md5:对应请求头中 HTTP_CONTENT_MD5
- referrer:对应请求头中 HTTP_REFERER
- date:对应请求头中 HTTP_DATE
- max_forwards:对应请求头中 HTTP_MAX_FORWARDS

## werkzeug.wrappers.Response

Response是应用返回数据给客户端的终点,也就是application的`__call__`方法最后是为了返回数据给客户端,而application最后是返回了Reponse对象,Response对象通过实现`__call__(self,environ,start_response)`来实现wagi的应用协议
Response的call方法
```python
def __call__(self, environ, start_response):
    """Process this response as WSGI application.

    :param environ: the WSGI environment.
    :param start_response: the response callable provided by the WSGI
                            server.
    :return: an application iterator
    """
    app_iter, status, headers = self.get_wsgi_response(environ)
    start_response(status, headers)
    return app_iter
```

源代码
```python
class Response(BaseResponse, ETagResponseMixin, ResponseStreamMixin,
               CommonResponseDescriptorsMixin,
               WWWAuthenticateMixin):
```
BaseResponse:
- set_cookie:设置cookie

## 请求

Request继承自werkzeug.wrappers.Request和JSONMixin

```python
class Request(RequestBase, JSONMixin):
```
JSONMixin:
- is_json:判断请求是否发送的是json数据类型
- json: 如果请求的数据是json数据类型,那么这里获得的时候json数据字典

## 响应

Response继承自werkzeug.wrappers.Response和JSONMixin

```python
class Response(ResponseBase, JSONMixin)
```

# 路由
flask路由基于werkzeug.routing 中的 Map和Rule

```python
self.url_map = Map([
    Rule('/', endpoint='new_url'),
    Rule('/<short_id>', endpoint='follow_short_link'),
    Rule('/<short_id>+', endpoint='short_link_details')
])
```
werkzeug中通过匹配Rule中的正则来找到endpoint字符串,falsk中@route装饰器也是通过向self.map(self.map=Map())中添加Rule对象来实现路由配置. werkzeug中的是通过endpoint来找到对应的函数,

具体过程werkzeug中:
1. 创建路由器
2. 路由器匹配路径
3. 找到endpoint字符串
4. 查找当前对象的on_{endpoint}方法
```python
def dispatch_request(self, request):
    adapter = self.url_map.bind_to_environ(request.environ)
    try:
        endpoint, values = adapter.match()
        return getattr(self, 'on_' + endpoint)(request, **values)
    except HTTPException, e:
        return e
```
flask中请求到-->`__call__`-->`wsgi_app`-->`full_dispatch_request`-->`dispatch_request`

flask绑定路径与函数是可以通过@route装饰器,该装饰器,就是往self.map中添加一条Rule,而每一个Rule最终匹配出来的是endpoint字符串,flask通过一个字典也就是self.view_functions来绑定enpoint和函数`self.view_functions[endpoint] = view_func`,当请求到来时,flask调用路由匹配,来匹配到一个Rule,并绑定到`req.url_rule`上,并通过s`elf.view_functions[req.url_rule.enpoint]`来找到绑定的函数,并调用该函数

```python
def dispatch_request(self):
    req = _request_ctx_stack.top.request
    if req.routing_exception is not None:
        self.raise_routing_exception(req)
    rule = req.url_rule
    # if we provide automatic options for this URL and the
    # request came with the OPTIONS method, reply automatically
    if getattr(rule, 'provide_automatic_options', False) \
        and req.method == 'OPTIONS':
        return self.make_default_options_response()
    # otherwise dispatch to the handler for that endpoint
    return self.view_functions[rule.endpoint](**req.view_args)
```

# session

flask中默认的session工具是`session_interface=SecureCookieSessionInterface`,这个类是将session数据保存到了客户端,并且将session数据进行了加密,然后到服务器端,在通过找到该cookie的值,并解析出来

flask通过调用
- open_session: 来打开获取session数据
- save_session: 来保存session数据

session数据支持map操作也就是实现了`__setitem__`和`__getitem__`

## 使用redis来保存session 简单实现

```python
app=Flask(__name__)
reds_conn = redis.Redis()
class RedisSession(object):
    def __init__(self, data={}, session_id=None):
        self.modified = False
        self.session_id = session_id
        self.data = data

    def __setitem__(self, key, value):
        self.modified = True
        self.data[key] = value

    def __getitem__(self, key):
        return self.data[key]

    def __repr__(self):
        return str(self.data)


class RedisSessionInterface(SessionInterface):
    def open_session(self, app, request):
        # 查找redis中保存的session数据
        session_id = request.cookies.get(app.session_cookie_name, False)
        if not session_id:
            session_id = str(uuid.uuid1())
        data = reds_conn.get(session_id)
        if data:
            data = json.loads(data.decode())
        else:
            data = {}
        return RedisSession(data=data, session_id=str(uuid.uuid1()))

    def save_session(self, app, session, response):
        # 如果session数据发生了变化就把session数据保存到redis中
        if session.modified:
            reds_conn.set(session.session_id, json.dumps(
                session.data), ex=app.permanent_session_lifetime)

        response.set_cookie(
            app.session_cookie_name,
            session.session_id,
            expires=datetime.utcnow() + app.permanent_session_lifetime,
            httponly=True
        )

app.session_interface = RedisSessionInterface()
```

 






